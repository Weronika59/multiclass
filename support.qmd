---
title: "SUPPORT2"
author: "Weronika Nadworska"
format: 
  html:
    warning: false
    message: false
    echo: true
    self-contained: true
    self-contained-math: true
    embed-resources: true
    lang: pol
editor: visual
toc: true
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(dplyr)
library(kableExtra)
library(corrplot)
library(tidyr)
library(caret)
library(rstatix)
library(keras)
library(tensorflow)
library(tidymodels)
library(gt)
library(RColorBrewer)
```

## Wstęp

Projekt SUPPORT składał się z dwuletniego prospektywnego badania obserwacyjnego (Faza I), po którym nastąpiło dwuletnie kontrolowane badanie kliniczne (Faza II). Jego celem była poprawa procesu decyzyjnego, aby odpowiedzieć na rosnące krajowe obawy dotyczące utraty kontroli przez pacjentów pod koniec życia i zmniejszyć częstotliwość mechanicznego, bolesnego i długotrwałego procesu umierania.

W fazie I badania SUPPORT zebrano dane od pacjentów przyjętych w latach 1989-1991 w celu scharakteryzowania opieki, preferencji dotyczących leczenia i wzorców podejmowania decyzji wśród krytycznie chorych pacjentów. Służyła również jako wstępny krok do opracowania strategii interwencji w celu poprawy opieki nad krytycznie chorymi pacjentami oraz do budowy modeli statystycznych do przewidywania rokowania i stanu funkcjonalnego pacjenta. Interwencja została wdrożona w II fazie badania SUPPORT, do której pacjenci byli przyjmowani w latach 1992-1994.

Wszyscy pacjenci w pięciu ośrodkach medycznych w Stanach Zjednoczonych spełnili kryteria włączenia i wykluczenia dla dziewięciu kategorii chorób: ostra niewydolność oddechowa, przewlekła obturacyjna choroba płuc, zastoinowa niewydolność serca, choroba wątroby, śpiączka, rak okrężnicy, rak płuc, niewydolność wielonarządowa z nowotworem złośliwym i niewydolność wielonarządowa z posocznicą. SUPPORT to połączenie pacjentów z dwóch badań, z których każde trwało 2 lata. Pierwsza faza dotyczyła 4 301 pacjentów, podczas gdy druga faza dotyczyła 4 804 pacjentów. Pod względem czasu, badania te zostały przeprowadzone w 1989 r. (12 czerwca) do 1991 r. (11 czerwca) dla fazy I oraz w 1992 r. (7 stycznia) do 1994 r. (24 stycznia).

## Cel badania

Celem tego badania jest zbudowanie zaawansowanego modelu uczenia maszynowego prognozującego stopień niepełnosprawności funkcjonalnej pacjenta oraz prawdopodobieństwo śmierci (ogólnie), jak i prawdopodobieństwo śmierci w szpitalu. Będzie to pomocne głównie lekarzom i pielęgnioarkom oraz osobom opiekującym się chorymi we wcześniejszym podejmowaniu odpowiednich decyzji co do procesu leczenia i planowania w celu zmniejszenia częstotliwości mechanicznego, bolesnego i przedłużającego się procesu umierania.

## Opis zbioru badawczego

Zbiór `SUPPORT2` pochodzi z witryny [UCI](https://archive.ics.uci.edu/dataset/880/support2) i obejmuje 9105 pacjentów w stanie krytycznym z 5 ośrodków medycznych w Stanach Zjednoczonych. Każdy wiersz dotyczy hospitalizowanego pacjenta, który spełnił kryteria włączenia i wykluczenia dla dziewięciu kategorii chorób: ostra niewydolność oddechowa, przewlekła obturacyjna choroba płuc, zastoinowa niewydolność serca, choroba wątroby, śpiączka, rak okrężnicy, rak płuc, niewydolność wielonarządowa z nowotworem złośliwym i niewydolność wielonarządowa z sepsą.

Zbiór zawiera następujące informacje na temat hospitalizowanych pacjentów:

-   `age` - wiek pacjenta w latach,

-   `death` (**target**) - śmierć w dowolnym momencie trwania badania aż do 31 grudnia 1994 roku; niektórzy pacjenci zostali wypisani przed zakończeniem badania i nie byli monitorowani, ale autorzy sprawdzili informacje o zgonach (0/1),

-   `sex` - płeć pacjenta (*male/female*),

-   `hospdead` (**target**) - binarna zmienna oznaczająca śmierć w szpitalu (0/1),

-   `slos` - liczba dni od rozpoczęcia badania do wypisu ze szpitala,

-   `d.time` - liczba dni obserwacji do momentu śmierci pacjenta,

-   `dzgroup` - podkategorie choroby pacjenta: ostra niewydolność nerek/niewydolność wielonarządowa z sepsą (*ARF/MOSF w/Sepsis*), zastoinowa niewydolność serca (*CHF*), przewlekła obturacyjna choroba płuc (*COPD*), marskość wątroby (*Cirrhosis*), rak okrężnicy (*Colon Cancer*), śpiączka (*Coma*), rak płuc (*Lung Cancer*), niewydolność wielonarządowa z nowotworem złośliwym (*MOSF w/Malig*),

-   `dzclass` - kategoria choroby pacjenta: ostra niewydolność nerek/niewydolność wielonarządowa (*ARF/MOSF*), przewlekła obturacyjna choroba płuc/zastoinowa niewydolność serca/marskość wątroby (*COPD/CHF/Cirrhosis*), rak (*Cancer*), śpiączka (*Coma*),

-   `num.co` - liczba jednoczesnych chorób (lub chorób współistniejących) występujących u pacjenta; wartości są porządkowe, przy czym wyższe wartości wskazują na gorszy stan i mniejsze szanse na przeżycie,

-   `edu` - lata edukacji (liczba z zakresu od 11 do 28),

-   `income` - dochód pacjenta (poziomy *\$11-\$25k*, *\$25-\$50k*, *\>\$50k*, *under \$11k*),

-   `scoma` - wynik śpiączki w 3. dniu badania SUPPORT na podstawie skali Glasgow (przewidywany na podstawie modelu); liczba z zakresu 0-100,

-   `charges` - opłaty szpitalne,

-   `totcst` - całkowity stosunek kosztów do opłat,

-   `totmcst` - całkowity koszt mikro,

-   `avtisst` - średni wynik TISS (*Therapeutic Intervention Scoring System*) - to metoda obliczania kosztów na oddziale intensywnej terapii i oddziale opieki pośredniej,

-   `race` - rasa pacjenta (poziomy *asian*, *black*, *hispanic*, *missing*, *other*, *white*),

-   `meanbp` - średnie ciśnienie tętnicze krwi pacjenta mierzone w dniu 3.,

-   `wblc` - liczba białych krwinek (w tysiącach) zmierzona w dniu 3.,

-   `hrt` - częstość akcji serca pacjenta mierzona w dniu 3.,

-   `resp` - częstość oddechów pacjenta mierzona w dniu 3.,

-   `temp` - temperatura w stopniach Celsjusza zmierzona w dniu 3.,

-   `pafi` - stosunek tętniczego ciśnienia parcjalnego tlenu do frakcji wdychanego tlenu zmierzony w dniu 3.; mniejsze wartości oznaczają większą śmiertelność,

-   `alb` - poziom albuminy w surowicy mierzony w dniu 3.,

-   `bili` - poziom bilirubiny mierzony w dniu 3.,

-   `crea` - poziom kreatyniny w surowicy mierzony w dniu 3.,

-   `sod` - stężenie sodu w surowicy mierzone w dniu 3.,

-   `ph` - pH krwi tętniczej; zwykle w zakresie od 7,35 do 7,45,

-   `glocuse` - poziom glukozy mierzony w dniu 3.,

-   `bun` - poziom azotu mocznikowego we krwi mierzony w dniu 3.,

-   `urine` - ilość moczu mierzona w 3. dniu,

-   `adlp` - indeks czynności życia codziennego pacjenta wypełniany przez pacjenta, mierzony w dniu 3.; wyższe wartości wskazują na większe szanse na przeżycie,

-   `adls` - indeks czynności życia codziennego pacjenta, wypełniany przez osobę zastępczą (np. członka rodziny), mierzony w 3. dniu; wyższe wartości wskazują na większe szanse na przeżycie,

-   `sfdm2` (**target**) - poziom niepełnosprawności funkcjonalnej pacjenta w skali od 1 do 5, gdzie 5 oznacza najwyższy stopień nasilenia; wartości są skorelowane z kolumnami `adls` oraz `adlp`.

    Objaśnienie poziomów zmiennej:

    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
    | Nazwa w zbiorze danych   | Poziom niepełnosprawności | Opis                                                                                                                                  |
    +==========================+===========================+=======================================================================================================================================+
    | no(Month 2 and SIP pres) | 1                         | Po 2-miesięcznwj obserwacji, a następnie wywiadzie, nie stwierdzono oznak umiarkowanej lub ciężkiej niepełnosprawności funkcjonalnej. |
    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
    | adl\>=4 (\>=5 if sur)    | 2                         | Pacjent nie był w stanie wykonywać 4 lub więcej czynności życia codziennego w 2. miesiącu po rozpoczęciu badania.                     |
    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
    | SIP\>=30                 | 3                         | Całkowity wynik profilu wpływu choroby po 2 miesiącach.                                                                               |
    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
    | Coma or Intub            | 4                         | Pacjent zaintubowany lub w śpiączce po 2 miesiącach.                                                                                  |
    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
    | \<2 mo. follow-up        | 5                         | Pacjent zmarł przed upływem 2 miesięcy od rozpoczęcia badania.                                                                        |
    +--------------------------+---------------------------+---------------------------------------------------------------------------------------------------------------------------------------+

-   `adlsc` - imputowany indeks czynności życia codziennego skalibrowany do surogatu.

Zmienne z grugiej fazy badania SUPPORT:

-   `sps` - wynik fizjologii SUPPORT w dniu 3. (przewidywany przez model),

-   `aps` - wynik fizjologiczny APACHE III w dniu 3.,

-   `surv2m` - szacunkowe 2-miesięczne przeżycie w 3. dniu (przewidywane przez model),

-   `surv6m` - szacunkowe 6-miesięczne przeżycie w 3. dniu (przewidywane przez model),

-   `hday` - dzień pobytu w szpitalu, w którym pacjent został włączony do badania,

-   `diabetes` - występowanie cukrzycy jako choroby współistniejącej (0/1),

-   `dementia` - występowanie demencji jako choroby współistniejącej (0/1),

-   `ca` - określenie, czy pacjent ma raka (*yes*), czy rak się rozprzestrzenił (*metastatic*) lub czy jest zdrowy (*no*),

-   `prg2m` - oszacowane przez lekarza prawdopodobieństwo 2-miesięcznego przeżycia pacjenta,

-   `prg6m` - oszacowane przez lekarza prawdopodobieństwo 6-miesięcznego przeżycia pacjenta,

-   `dnr` - określenie, czy pacjent ma nakaz nieresuscytowania (DNR); możliwe poziomy to *dnr after sadm*, *dnr before sadm*, *missing*, *no dnr*,

-   `dnrday` - dzień zlecenia DNR (mniejszy od 0, jeśli przed badaniem).

Zawarte na [stronie](https://hbiostat.org/data/repo/supportdesc) dodatkowe informacje nt. zbioru danych informują o optymalnych wartościach danych fizjologicznych pacjentów, które zostały uznane za zadowalające w zastępowaniu ich brakujących wartości.

| Nazwa zmiennej | Proponowana wartość zastąpienia jej braku danych |
|----------------|--------------------------------------------------|
| `alb`          | 3,5                                              |
| `pafi`         | 333,3                                            |
| `bili`         | 1,01                                             |
| `crea`         | 1,01                                             |
| `bun`          | 6,51                                             |
| `wblc`         | 9 (w tysiącach)                                  |
| `urine`        | 2502                                             |

: Optymalne wartości imputacji braków danych wybranych zmiennych

We wspomnianych dodatkowych informacjach jest również uwaga, że aby opracować modele bez korzystania z wyników poprzednich modeli, nie należy uwzględniać zmiennych `aps`, `sps`, `surv2m`, `surv6m`, `prg2m`, `prg6m`, `dnr` oraz `dnrday` jako predyktorów.

Poniżej zaprezentowano pięć początkowych obserwacji zbioru badawczego.

```{r}
dane <- read.csv("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\support2.csv", na.strings = c("NA",""))
```

```{r}
options(knitr.kable.NA='NA')
head(dane, 5) |> kable(caption = "Dane pochodzące z witryny UCI") |> kable_styling()
```

Uwzględniając uwagi zawarte na [stronie](https://hbiostat.org/data/repo/supportdesc), ze zbioru zostaną usunięte zmienne `aps`, `sps`, `surv2m`, `surv6m`, `prg2m`, `prg6m`, `dnr` oraz `dnrday`.

```{r}
dane <- dane[,-c(18:21,26:29)]
```

```{r}
options(knitr.kable.NA='NA')
head(dane, 5) |> kable(caption = "Dane bez wymienionych kolumn") |> kable_styling()
```

Zmienna `wblc` (liczba białych krwinek) zostanie wyrażona w tysiącach dla lepszej interpretacji.

```{r}
dane$wblc <- dane$wblc*1000
```

#### Statystyki opisowe

Poniżej zaprezentowane są podstawowe statystyki opisowe dla zmiennych numerycznych.

```{r}
options(knitr.kable.NA=0)
pods <- sub(".*:", "",summary(dane[,c("age","slos", "d.time", "num.co", "edu", "scoma", "charges", "totcst", "totmcst", "avtisst", "hday", "meanbp", "wblc", "hrt", "resp", "temp", "pafi", "alb", "bili", "crea", "sod", "ph", "glucose", "bun", "urine", "adlp", "adls", "adlsc")]))
rownames(pods) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.", "NA's")
pods |> kable() |> kable_styling(full_width = T, bootstrap_options  = "striped")
```

Na podstawie powyższych danych, widzimy, że najmłodszy badany pacjent miał 18 lat, a najstarszy 101.

Są pacjenci, którzy nie mają za sobą lat edukacji (wartość 0). Jest to nieco dziwne zjawisko.

```{r}
dane[dane$edu==0,] |> drop_na(age) |> nrow()
```

Takich przypadków okazało się być 43.

Poniżej przedstawiono 3 przykładowe przypadki pacjentów, dla których lata edukacji wynoszą 0.

```{r}
dane[dane$edu==0,] |> drop_na(age) |> head(3) |> kable() |> kable_styling()
```

Intuicja podpowiada, że być może są to osoby starsze, które z różnych względów w ich wieku młodzieńczym nie mogły uczęszczać do szkoły. Rasa pacjentów także może sugerować skąd pochodzą i stąd można wyciągnąć wniosek o ewentualnym braku edukacji na tym terenie.

```{r}
options(knitr.kable.NA='NA')
dane[dane$edu==0,] |> drop_na(age) |> arrange(age) |> head(9) |> kable(caption = "Pacjenci z brakiem edukacji ułożeni względem wieku rosnąco") |> kable_styling()
```

Jednak wśród wyróżniowych 43 pacjentów najmłodszy z nich ma 25 lat i większość z nich jest rasy białej. Natomiast ciekawą obserwacją jest to, że niemal każdy z tych pacjentów zadeklarował roczny przychód poniżej 11 tys. dolarów, więc być może nie mogli oni pozwolić sobie na edukację ze względów finansowych. Warto tu także przypomnieć, że początki badania miały miejsce w roku 1989.

43 wyróżnione przypadki ze względu na zmienną `edu` nie są dużą liczbą i ze względu na to, że są to "podejrzane" obserwacje, możnaby podjać decyzję o ich usunięciu ze zbioru danych (stanowią one 0,47% całego zbioru), jednak ze względu na to, że każdy zbadany pacjent niesie za sobą konkretne informacje, a liczba lat edukacji nie jest jednym z głównych czynników w tym badaniu, a bardziej względy medyczne, nie zostaną one usunięte ze zbioru.

Wracając do tabeli ze statystykami opisowymi, zwracajac uwagę na koszty, możemy dostrzec, że minimalna wartość całkowitego kosztu mikro (`totmcst`) jest ujemna, co oznacza, że jest co najmniej jeden pacjent z zadłużeniem. Jest także pacjent, który za pobyt w szpitalu zapłacił niemal 1,5 mln dolarów (`charges`=1435423).

Zwracając uwagę na zmienne dotyczące stanu zdrowia pacjentów, możemy dostrzec, że zmienne `meanbp` , `wblc`, `hrt`, `resp`, `glucose`, `urine`, `adlp`, `adls` oraz `adlsc` swoją najmniejszą wartość mają równą 0, co może świadczyć o tym, że pacjent nie żyje, a na pewno są to podejrzane przypadki.

```{r}
dane[dane$meanbp==0 | dane$wblc==0 | dane$hrt==0 | dane$resp==0 | dane$glucose==0 | dane$urine==0 | dane$urine==0 | dane$adlp==0 | dane$adls==0 | dane$adlsc==0,] |> drop_na(age) |> nrow()
```

Obserwacji, dla których wymienione wyżej zmienne wynoszą 0, jest łącznie 4014. Jest to ponad 40% całego zbioru danych. Poza tym, podczas trwania badania, jak to było opisane we wstępie, pacjenci umierali i takie dane są wręcz naturalne. Dla przykładu, gdy średnie ciśnienie tętnicze wynosi 0, większość z tych pacjentów w kolumnie `hospdead` (śmierć w szpitalu) oraz `death` (śmierć w dowolnym momencie) ma wartość 1 (nie żyje). Podjęto zatem decyzję o nie usuwaniu tych przypadków ze zbioru danych.

Ponadto, jest 11 zmiennych, dla których liczba braków danych przekracza tysiąc - należy przeprowadzić odpowiednią metodę ich imputacji.

Przed przystąpieniem do prezentacji poziomów zmiennych kategorycznych, zostaną wykonane odpowiednie ich przekształcenia w postaci zakodowania ich jako zmienne typu `factor`.

```{r}
dane$death <- as.factor(dane$death) 
dane$hospdead <- as.factor(dane$hospdead) 
dane$diabetes <- as.factor(dane$diabetes) 
dane$dementia <- as.factor(dane$dementia) 
dane$sex <- ifelse(dane$sex=="male", 0, 1)
dane$sex <- as.factor(dane$sex) 
dane$dzgroup <- ifelse(dane$dzgroup=="Lung Cancer", 1, ifelse(dane$dzgroup=="Cirrhosis", 2, ifelse(dane$dzgroup=="Coma", 3, ifelse(dane$dzgroup=="CHF", 4, ifelse(dane$dzgroup=="Colon Cancer", 5, ifelse(dane$dzgroup=="COPD", 6, ifelse(dane$dzgroup=="MOSF w/Malig", 7, 8))))))) 
dane$dzgroup <- as.factor(dane$dzgroup) 
dane$dzclass <- ifelse(dane$dzclass=="Cancer", 1, ifelse(dane$dzclass=="ARF/MOSF", 2, ifelse(dane$dzclass=="Coma", 3, 4))) 
dane$dzclass <- as.factor(dane$dzclass) 
dane$income <- ifelse(dane$income=="under $11k", 1, ifelse(dane$income=="$11-$25k", 2, ifelse(dane$income=="$25-$50k", 3, ifelse(dane$income==">$50k", 4, NA)))) 
dane$income <- as.factor(dane$income) 
dane$race <- ifelse(dane$race=="white", 1, ifelse(dane$race=="black", 2, ifelse(dane$race=="asian", 3, ifelse(dane$race=="hispanic", 4, ifelse(dane$race=="other", 5, NA))))) 
dane$race <- as.factor(dane$race) 
dane$ca <- ifelse(dane$ca=="no", 0, ifelse(dane$ca=="yes", 1, 2)) 
dane$ca <- as.factor(dane$ca) 
dane$sfdm2 <- ifelse(dane$sfdm2=="<2 mo. follow-up", 0, ifelse(dane$sfdm2=="no(M2 and SIP pres)", 1, ifelse(dane$sfdm2=="SIP>=30", 2, ifelse(dane$sfdm2=="adl>=4 (>=5 if sur)", 3, ifelse(dane$sfdm2=="Coma or Intub", 4, NA))))) 
dane$sfdm2 <- as.factor(dane$sfdm2)
```

Tabela poniżej przedstawia informacje o sposobie zakodowania poszczególnych poziomów zmiennych kategorycznych w wyniku powyższego kodu.

+--------------------+----------------------+-----------------------+
| **Nazwa zmiennej** | **Poziomy zmiennej** | **Znaczenie**         |
+--------------------+----------------------+-----------------------+
| `death`            | 0                    | no                    |
|                    |                      |                       |
|                    | 1                    | yes                   |
+--------------------+----------------------+-----------------------+
| `hospdead`         | 0                    | no                    |
|                    |                      |                       |
|                    | 1                    | yes                   |
+--------------------+----------------------+-----------------------+
| `diabetes`         | 0                    | no                    |
|                    |                      |                       |
|                    | 1                    | yes                   |
+--------------------+----------------------+-----------------------+
| `dementia`         | 0                    | no                    |
|                    |                      |                       |
|                    | 1                    | yes                   |
+--------------------+----------------------+-----------------------+
| `sex`              | 0                    | male                  |
|                    |                      |                       |
|                    | 1                    | female                |
+--------------------+----------------------+-----------------------+
| `dzgroup`          | 1                    | Lung Cancer           |
|                    |                      |                       |
|                    | 2                    | Cirrhosis             |
|                    |                      |                       |
|                    | 3                    | ARF/MOSF w/Sepsis     |
|                    |                      |                       |
|                    | 4                    | Coma                  |
|                    |                      |                       |
|                    | 5                    | CHF                   |
|                    |                      |                       |
|                    | 6                    | Colon Cancer          |
|                    |                      |                       |
|                    | 7                    | COPD                  |
|                    |                      |                       |
|                    | 8                    | MOSF w/Malig          |
+--------------------+----------------------+-----------------------+
| `dzclass`          | 1                    | Cancer                |
|                    |                      |                       |
|                    | 2                    | COPD/CHF/Cirrhosis    |
|                    |                      |                       |
|                    | 3                    | ARF/MOSF              |
|                    |                      |                       |
|                    | 4                    | Coma                  |
+--------------------+----------------------+-----------------------+
| `income`           | 1                    | under \$11k           |
|                    |                      |                       |
|                    | 2                    | \$11-\$25k            |
|                    |                      |                       |
|                    | 3                    | \$25-\$50k            |
|                    |                      |                       |
|                    | 4                    | \>\$50k               |
+--------------------+----------------------+-----------------------+
| `race`             | 1                    | white                 |
|                    |                      |                       |
|                    | 2                    | black                 |
|                    |                      |                       |
|                    | 3                    | asian                 |
|                    |                      |                       |
|                    | 4                    | hispanic              |
|                    |                      |                       |
|                    | 5                    | other                 |
+--------------------+----------------------+-----------------------+
| `ca`               | 0                    | no                    |
|                    |                      |                       |
|                    | 1                    | yes                   |
|                    |                      |                       |
|                    | 2                    | metastatic            |
+--------------------+----------------------+-----------------------+
| `sfdm2`            | 0                    | \<2 mo. follow-up     |
|                    |                      |                       |
|                    | 1                    | no(M2 and SIP pres)   |
|                    |                      |                       |
|                    | 2                    | SIP\>=30              |
|                    |                      |                       |
|                    | 3                    | adl\>=4 (\>=5 if sur) |
|                    |                      |                       |
|                    | 4                    | Coma or Intub         |
+--------------------+----------------------+-----------------------+

Poniżej przedstawiono 5 początkowych wierszy danych po wymienionych wyżej transformacjach.

```{r}
options(knitr.kable.NA='NA') 
head(dane, 5) |> kable() |> kable_styling()
```

Dodatkowo, dla ułatwienia wyciągania wniosków w dalszych etapach badania, trzy zmienne wynikowe: `death`, `hospdead` oraz `sfdm2`zostaną umieszczone jako trzy ostatnie kolumny w tym zbiorze danych.

```{r}
dane <- dane[,c(1,3,5:37,39,2,4,38)]
```

```{r}
options(knitr.kable.NA='NA') 
head(dane, 5) |> kable(caption = "Dane po zamianie kolejnością zmiennych") |> kable_styling()
```

Zatem możliwe poziomy oraz ich liczby wystąpień dla każdej zmiennej kategorycznej w tym zbiorze prezentują się następująco:

```{r}
options(knitr.kable.NA='')
summary(dane[,c("sex", "dzgroup", "dzclass", "income", "race", "diabetes", "dementia", "ca", "death", "hospdead", "sfdm2")]) |> kable() |> kable_styling(full_width = T, bootstrap_options  = "striped")
```

Na podstawie powyższej tabeli, widzimy, że w zmiennych `income` oraz `sfdm2` liczba braków danych jest duża (ponad tysiąc). Ponadto większość widocznych zmiennych kategorycznych charakteryzuje się niezbalansowaniem klasowym, co może mieć wpływ na wyniki zbudowanego modelu w późniejszym etapie.

#### Braki danych

Poniżej zaprezentowana jest liczba braków danych w każdej z kolumn.

```{r}
braki <- colSums(is.na(dane)) 
braki <- cbind(braki)
colnames(braki) <- "Liczba braków"
braki |> kable()|> kable_styling(full_width = F, bootstrap_options  = "striped")
```

Jak widać, braki danych pojawiają się w kolumnach: `scoma`, `meanbp`, `hrt`, `resp`, `temp`, `sod` (tylko 1), `avtisst`, `race`, `crea` (do 100), `charges`, `totcst`, `wblc` (od 101 do 1000), `edu`, `income`,`totmcst`, `pafi`, `alb`, `bili`, `ph`, `glucose`, `bun`, `urine`, `adlp`, `adls`, `sfdm2` (ponad tysiąc).

Aby przeprowadzić odpowiednią metodę imputacji braków danych, zostaną zbadane rozkłady poszczególnych zmiennych - na początku numerycznych.

```{r}
dane |> select(c("age","slos", "d.time", "num.co", "edu", "scoma", "charges", "totcst", "totmcst", "avtisst", "hday", "meanbp", "wblc", "hrt", "resp", "temp", "pafi", "alb", "bili", "crea", "sod", "ph", "glucose", "bun", "urine", "adlp", "adls", "adlsc")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(value, fill = name)) +
  geom_histogram(bins = 15, color = "white")+
  facet_wrap(~name, scales = "free")+
  theme(legend.position = "none")
```

Na podstawie powyższych rozkładów zmiennych numerycznych, widzimy, że:

-   (lekko) lewostronnie asymetryczny jest rozkład zmiennej `age`,

-   prawostronnie asymetryczny jest rozkład zmiennych: `adlp`, `adls`, `adlsc`, `alb`, `avtisst`, `bili`, `bun`, `charges`, `crea`, `d.time`, `glucose`, `hday`, `hrt`, `num.co`, `pafi`, `resp`, `scoma`, `slos`, `totcst`, `totmcst`, `urine` oraz `wblc`,

-   prawostronna asymetria występuje dla zmiennych związanych z kosztami (`charges`, `totcst`, `totmcst`), co sugeruje, że większość pacjentów ponosi niskie koszty leczenia lub ma mniej poważne wyniki kliniczne. Może to odzwierciedlać większe wykorzystanie zasobów szpitalnych w bardziej krytycznych przypadkach.

-   Są zmienne takie jak `bili`, `charges`, `scoma`, `slos`, czy `hday`, które charakteryzują się długimi ogonami na wykresach, co sugeruje obecność wartości odstających.

-   Rozkłady parametrów fizjologicznych (`meanbp`, `hrt`, `resp`, `temp`) mają tendencję do bycia bardziej scentralizowanymi, wskazując na pewien stopień jednorodności tych pomiarów w całej populacji pacjentów, z pewnymi znaczącymi odchyleniami od wartości centralnych.

-   Podobnie, jak w przypadku parametrów fizjologicznych, pomiary laboratoryjne (`pafi`, `alb`, `bili`, `crea`, `sod`, `ph`, `glucose`, `bun`, `urine`) wykazują tendencje centralne o różnym stopniu skośności, co sugeruje zakres wartości zgodny z populacją pacjentów szpitalnych.

```{r}
dane |> select(-c("age", "slos", "d.time", "num.co", "edu", "scoma", "charges", "totcst", "totmcst", "avtisst", "hday", "meanbp", "wblc", "hrt", "resp", "temp", "pafi", "alb", "bili", "crea", "sod", "ph", "glucose", "bun", "urine", "adlp", "adls", "adlsc")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(value, fill = name)) +
  geom_bar()+
  facet_wrap(~name, scales = "free")+
  theme(legend.position = "none")
```

Na podstawie powyższych rozkładów zmiennych kategorycznych, widzimy, że każda ze zmiennych charakteryzuje się niezbalansowaniem. Dla zmiennej `dementia` czy `race` poszczególne poziomy wyróżniają się znaczącymi różnicami liczebnościowymi. Liczba braków danych dla `income` jest bardzo duża jest równa liczebności występowania pierwszej kategorii tej zmiennej. Liczba braków zmiennej `race` nie jest duża w porównaniu z jej poszczególnymi kategoriami, natomiast liczba braków zmiennej `sfdm2` znacznie się wyróżnia i jest duża.

##### Imputacja braków danych

Zgodnie z zaleceniami na stronie wspomnianej na początku, najrozsądniejszym sposobem radzenia sobie z brakującymi wartościami w kolumnach `alb`, `pafi`, `bili`, `crea`, `bun`, `wblc` i `urine` jest wypełnienie brakujących wartości zalecanymi tam wartościami. Analizując jednak rozkłady tych zmiennych przedstawione wyżej oraz na liczebność braków danych dla tych zmiennych, a także ze względu niezbalansowanie zmiennych jakościowych w tym zbiorze, zastosowana zostanie metoda imputacji $k$-najbliższych sąsiadów (tu 5). Zmienna `income`, ze względu na to, że liczba braków danych dla niej stanowi niemal 50%, zostanie usunięta ze zbioru danych.

```{r}
dane2 <- DMwR2::knnImputation(dane[,c("scoma", "meanbp", "hrt", "resp", "temp", "sod", "avtisst", "race", "crea", "charges", "totcst", "wblc", "edu", "totmcst", "pafi", "alb", "bili", "ph", "glucose", "bun", "urine", "adlp", "adls", "sfdm2")], k=5, meth='pmm')
dane3 <- bind_cols(dane[,c(1:7,16:19,36:38)], dane2)

#odpowiednia kolejnosc kolumn
dane3 <- dane3[,c(1:12,15:37,13,14,38)]
```

```{r}
dane3 |> select(-c("age", "slos", "d.time", "num.co", "edu", "scoma", "charges", "totcst", "totmcst", "avtisst", "hday", "meanbp", "wblc", "hrt", "resp", "temp", "pafi", "alb", "bili", "crea", "sod", "ph", "glucose", "bun", "urine", "adlp", "adls", "adlsc")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(value, fill = name)) +
  geom_bar()+
  facet_wrap(~name, scales = "free")+
  theme(legend.position = "none")+
  ggtitle("Rozkłady zmiennych kategorycznych po imputacji braków danych")
```

#### Macierz korelacji

```{r}
data_cor = cor(dane3[,c("age","slos", "d.time", "num.co", "edu", "scoma", "charges", "totcst", "totmcst", "avtisst", "hday", "meanbp", "wblc", "hrt", "resp", "temp", "pafi", "alb", "bili", "crea", "sod", "ph", "glucose", "bun", "urine", "adlp", "adls", "adlsc")], use = "na.or.complete")
corrplot(data_cor, tl.cex = 0.6)
```

Z macierzy korelacji dla zmiennych numerycznych, wyczytać możemy, że istnieją silne korelacje pomiędzy zmiennymi: `charges` i `totcst` (0,80) oraz `adlsc` i `adls` (0,89), a także umiarkowane korelacje pomiędzy zmiennymi `slos` i `charges` (0,63), `slos` i `totcst` (0,72), `slos` i `totmcst` (0,65), `charges` i `totmcst` (0,74), `bun` i `crea` (0,69), `adls` i `adlp` (0,64) oraz `adlsc` i `adlp` (0,59).

Związane są ze sobą zatem zmienne:

-   liczba dni pobytu w szpitalu i kosztów z nimi związanych,

-   opłaty szpitalne oraz koszty i mikrokoszty pobytu w szpitalu - w tym przypadku ze wbioru zostaną usunięte kolumny `totcst` oraz `totmcst`.

-   Poziom azotu mocznikowego we krwi oraz poziom kreatyniny w surowicy,

-   indeksy czynności życia codziennego pacjenta wypełniane przez niego, osobę zastępczą oraz skalibrowane do surogatu - tutaj ze względu na bardzo silną korelację, jedna z kolumn `adls` oraz `adlsc` zostanie usunięta ze zbioru.

```{r}
dane3 <- dane3[,-35] #adls
dane3 <- dane3[,-c(23,26)] #totcst i totmcst
```

#### Wartości odstające

```{r}
nearZeroVar(dane3)
```

Dla zmiennej `dementia` stosunek częstotliwości najczęściej występującej wartości (0) do częstotliwości drugiej najczęściej występującej wartości (1) jest duży, co potwierdzają także wcześniejsze obserwacje na wykresie z rozkładem tej zmiennej.

```{r}
dane3 |> 
  select(where(is.numeric)) |> 
  findLinearCombos()
```

Brak jest w tym zbiorze danych kombinacji liniowych pomiędzy predyktorami.

```{r}
dane3 |> 
  select(-c("death", "sex", "hospdead", "dzgroup", "dzclass", "diabetes", "dementia", "ca", "race", "sfdm2")) |>
  pivot_longer(cols = everything()) |> 
  ggplot(aes(value, fill = name)) +
  geom_boxplot()+
  facet_wrap(~name, scales = "free")+
  theme(legend.position = "none")
```

Powyższe wykresy ramka-wąsy wskazują, że niemal dla każdej zmiennej numerycznej istnieją wartości odstające.

Za pomocą funkcji `rstatix::identify_outliers()`, zbadano liczbę wartości odstających oraz ekstremalnych w tym zbiorze.

```{r echo=FALSE}
#identify_outliers(dane3, colnames(dane3)[1])[identify_outliers(dane3, colnames(dane3)[1])$is.outlier==T,] #age - 56, brak extreme

#identify_outliers(dane3, colnames(dane3)[3])[identify_outliers(dane3, colnames(dane3)[3])$is.outlier==T,] #slos - 768, 347 extreme

#identify_outliers(dane3, colnames(dane3)[4])[identify_outliers(dane3, colnames(dane3)[4])$is.outlier==T,] #d.time - 267, brak extreme

#identify_outliers(dane3, colnames(dane3)[7])[identify_outliers(dane3, colnames(dane3)[7])$is.outlier==T,] #num.co - 25, brak extreme

#identify_outliers(dane3, colnames(dane3)[8])[identify_outliers(dane3, colnames(dane3)[8])$is.outlier==T,] #hday - 1543, 1118 extreme

#identify_outliers(dane3, colnames(dane3)[12]) #adlsc - brak

#identify_outliers(dane3, colnames(dane3)[24])[identify_outliers(dane3, colnames(dane3)[24])$is.outlier==T,] #edu - 654, 68 extreme

#identify_outliers(dane3, colnames(dane3)[13])[identify_outliers(dane3, colnames(dane3)[13])$is.outlier==T,] #scoma - 1955, 1516 extreme

#identify_outliers(dane3, colnames(dane3)[22])[identify_outliers(dane3, colnames(dane3)[22])$is.outlier==T,] #charges - 928, 458 extreme

#identify_outliers(dane3, colnames(dane3)[19])[identify_outliers(dane3, colnames(dane3)[19])$is.outlier==T,] #avtisst - 48, brak extreme

#identify_outliers(dane3, colnames(dane3)[14])[identify_outliers(dane3, colnames(dane3)[14])$is.outlier==T,] #meanbp - 6, brak extreme

#identify_outliers(dane3, colnames(dane3)[23])[identify_outliers(dane3, colnames(dane3)[23])$is.outlier==T,] #wblc - 419, 123 extreme

#identify_outliers(dane3, colnames(dane3)[15])[identify_outliers(dane3, colnames(dane3)[15])$is.outlier==T,] #hrt - 419, 1 extreme

#identify_outliers(dane3, colnames(dane3)[16])[identify_outliers(dane3, colnames(dane3)[16])$is.outlier==T,] #resp - 313, 23 extreme

#identify_outliers(dane3, colnames(dane3)[17])[identify_outliers(dane3, colnames(dane3)[17])$is.outlier==T,] #temp - 14, brak extreme

#identify_outliers(dane3, colnames(dane3)[25])[identify_outliers(dane3, colnames(dane3)[25])$is.outlier==T,] #pafi - 154, 10 extreme

#identify_outliers(dane3, colnames(dane3)[26])[identify_outliers(dane3, colnames(dane3)[26])$is.outlier==T,] #alb - 67, 4 extreme

#identify_outliers(dane3, colnames(dane3)[27])[identify_outliers(dane3, colnames(dane3)[27])$is.outlier==T,] #bili - 1076, 717 extreme

#identify_outliers(dane3, colnames(dane3)[21])[identify_outliers(dane3, colnames(dane3)[21])$is.outlier==T,] #crea - 989, 539 extreme

#identify_outliers(dane3, colnames(dane3)[28])[identify_outliers(dane3, colnames(dane3)[28])$is.outlier==T,] #ph - 239, 32 extreme

#identify_outliers(dane3, colnames(dane3)[29])[identify_outliers(dane3, colnames(dane3)[29])$is.outlier==T,] #glucose - 481, 130 extreme

#identify_outliers(dane3, colnames(dane3)[30])[identify_outliers(dane3, colnames(dane3)[30])$is.outlier==T,] #bun - 726, 191 extreme
```

Obserwacje zidentyfikowane jako odstające nie zidentyfikowano tylko dla zmiennej `adlsc`. Najliczniej występują one dla zmiennej `scoma` i ich liczba wynosi niemal dwa tysiące. Samych wartości ekstremalnych dla tej zmiennej jest nieco ponad 1,5 tysiąca. Usunięcie tych obserwacji to pozbycie się prawie 20% zbioru, co byłoby niepoprawnym działaniem. Biorąc także pod uwagę, że dane dotyczą najbardziej chorych pacjentów, wartości odstające jeśli chodzi o dane medyczne są wręcz naturalne i niosą ze sobą cenne informacje. Na ten moment zidentyfikowane wartości pozostaną w zbiorze danych.

## Wizualizacje zbioru

#### Rozkłady wieku pacjentów w podziale na różne diagnozy

-   `dzclass` - kategoria choroby pacjenta

```{r}
    my_title <- expression(paste("Rozkład wieku w podziale na ", italic("dzclass")))
        dane3 |>  
          ggplot(aes(x=age, fill=dzclass))+
          geom_density(alpha=0.6)+
          labs(title = my_title)+
          scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Ostra niewydolność nerek/Niewydolność wielonarządowa (*ARF/MOSF*) (1) koncentruje się wokół 70 lat i tam osiąga swój szczyt.

2.  Przewlekła obturacyjna choroba płuc/Zastoinowa niewydolność serca/Marskość wątroby (*COPD/CHF/Cirrhosis*) (2) również ma szeroki rozkład wiekowy, ze szczytem około 70-75 lat, co sugeruje, że choroby te są bardziej powszechne u starszych osób dorosłych. Ale za to, to rozkład tej choroby obejmuje najwięcej ludzi modych (20-35 lat) spośród wszystkich czterech kategorii.

3.  Rak (*Cancer*) (3) ma najszerszy rozkład spośród badanych grup - dotyczy szerokiego przedziału wiekowego, także w większej liczbie dotyka osób młodych, ale osiąga szczyt dla pacjentów w wieku około 60-70 lat.

4.  Rozkład dla śpiączki (*Coma*) (4) ma tendencję do pochylania się w kierunku młodszego wieku, ze szczytem około 20-30 lat i długim ogonem rozciągającym się na starsze grupy wiekowe.

-   `dzgroup` - podkategorie choroby pacjenta

```{r}
my_title <- expression(paste("Rozkład wieku w podziale na ", italic("dzgroup")))
    dane3 |> 
      ggplot(aes(x=age, fill=dzgroup))+
      geom_density(alpha=0.6)+
      labs(title = my_title)+
      scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Choroby takie jak rak płuc (*Lung Cancer*) (1), ostra niewydolność nerek/niewydolność wielonarządowa z sepsą (*ARF/MOSF w/Sepsis*) (3), śpiączka (*Coma*) (4), zastoinowa niewydolność serca (*CHF*) (5), rak okrężnicy (*Colon Cancer*) (6), przewlekła obturacyjna choroba płuc (*COPD*) (7), niewydolność wielonarządowa z nowotworem złośliwym (*MOSF w/Malig*) (8) koncentrują się wokół wieku 65-80 lat. Zatem są one bardziej powszechne wśród starszych pacjentów.

2.  Choroby: przewlekła obturacyjna choroba płuc (*COPD*) (7), niewydolność wielonarządowa z nowotworem złośliwym (*MOSF w/Malig*) (8) znacznie się wyróżniają na tle pozostałych pod względem znacznego obejmowania także młodszych pacjentów (18-30 lat).

3.  Marskość wątroby (*Cirrhosis*) (2) koncentruje się wokół wieku około 40 lat, ale obejmuje także starszych pacjentów.

4.  Największą gęstość mają grupy chorób: rak płuc (*Lung Cancer*) (1), zastoinowa niewydolność serca (*CHF*) (5) oraz przewlekła obturacyjna choroba płuc (*COPD*) (6).

-   `ca` - definiuje, czy pacjent ma raka

```{r}
    my_title <- expression(paste("Rozkład wieku w podziale na ", italic("ca")))
    dane3 |>  
      ggplot(aes(x=age, fill=ca))+
      geom_density(alpha=0.6)+
      labs(title = my_title)+
      scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Pacjenci chorzy na raka (1) mają rozkład wieku koncentrujący się w wieku około 70-75 lat.

2.  Pacjenci niechorujący na raka (0) charakteryzują się podobnym rozkładem do pacjentów chorych na tę chorobę (1). Obejmują jednak oni więcej osób w wieku średnim (40-50 lat).

3.  Najwięcej osób chorujących na raka z przerzutami (2) jest w wieku 60-65 lat - koncentracja rozkładu gęstości ma tu swój szczyt.

-   `sfdm2` - poziom niepełnosprawności funkcjonalnej pacjenta

```{r}
    my_title <- expression(paste("Rozkład wieku w podziale na ", italic("sfdm2")))
    dane3 |> 
      ggplot(aes(x=age, fill=sfdm2))+
      geom_density(alpha=0.5)+
      labs(title = my_title)+
      scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Tutaj rozkłady wieku pacjentów ze względu na ich poziom niepełności funkcjonalnej są bardzo podobne. Koncentrują się wokół wieku 60-80 lat i obejmują więcej osób w wieku średnim (45-55 lat) niż tych starszych (80 i więcej).

2.  Wyróżnia się nieco bardziej rozkład dla niepełnosprawności na poziomie 4 (najwyższym) - obejmuje on znacznie więcej młodszych pacjentów (0-30 lat) w porównaniu z pozostałymi poziomami.

#### Rozkłady wieku w podziale na pacjentów chorych na cukrzycę oraz demencję

-   `diabetes` - cukrzyca

```{r}
    my_title <- expression(paste("Rozkład wieku w podziale na ", italic("diabetes")))
    dane3 |> 
      ggplot(aes(x=age, fill=diabetes))+
      geom_density(alpha=0.5)+
      labs(title = my_title)+
      scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Większość pacjentów bez cukrzycy (0) jest rozłożona w szerokim przedziale wiekowym, z największą liczbą w grupie 50-75 lat, osiągając szczyt około 70 lat.

2.  Rozkład wieku pacjentów z cukrzycą (1) ma bardziej skoncentrowany szczyt w wieku około 70 lat, co sugeruje, że cukrzyca jest bardziej rozpowszechniona w tej grupie wiekowej. Nakładanie się dwóch grup sugeruje, że chociaż cukrzyca występuje częściej w starszej populacji, nie jest ona wyłączna dla nich; młodsze grupy wiekowe również mają znaczną liczbę pacjentów z cukrzycą.

-   `dementia` - demencja

```{r}
    my_title <- expression(paste("Rozkład wieku w podziale na ", italic("dementia")))
    dane3 |> 
      ggplot(aes(x=age, fill=dementia))+
      geom_density(alpha=0.5)+
      labs(title = my_title)+
      scale_fill_brewer(palette="Set1")
```

**Wnioski**

1.  Tutaj widoczne są znaczne różnice pomiędzy pacjentami zdrowymi pod względem demencji (0), a chprującymi na tę chorobę (1). Pacjenci chorzy na demencję są głównie starsi od niechorujących na nią - koncentrują się w okolicach 80-85. roku życia.

2.  Jest bardzo niewielu młodszych pacjentów z demencją; rozkład pacjentów z demencją (1) wykazuje gwałtowny wzrost od około 60 roku życia i osiąga szczyt w wieku około 80 lat.

3.  Liczba pacjentów bez demencji (0) dotyczy także młodszych pacjentów, jednak szczyt osiąga dla wieku 65-70 lat, a potem gwałtownie spada.

#### Wykresy ramka-wąsy w wybranych grupach

-   `dzgroup` vs `slos`

```{r}
    ggplot(dane3, aes(x=dzgroup, y=slos, fill=dzgroup)) + 
        geom_boxplot()
```

Przedstawione powyżej wykresy ramka-wąsy wskazują, że pacjenci chorujący na ostrą niewydolność nerek/niewydolność wielonarządową z sepsą (3) oraz niewydolność wielonarządową z nowotworem złośliwym (8) mają wyższą medianę długości pobytu w szpitalu oraz większą zmienność tej cechy, a pacjenci chorujący na raka płuc (1) oraz zastoinową niewydolność serca mają najmniejszą medianę pobytu spośród wszystkich chorób i najmniejszą zmienność.

-   `dzgroup` vs `d.time`

    ```{r}
    ggplot(dane3, aes(x=dzgroup, y=d.time, fill=dzgroup)) +          
      geom_boxplot()
    ```

Te wykresy pudełkowy wskazują, że czas liczba dni obserwacji do momentu śmierci pacjenta różni się w zależności od grupy chorób. Pacjenci w śpiączce (4) oraz chorzy na raka okrężnicy mają największą medianę liczby dni do śmierci, podczas gdy pacjenci chorzy na ostrą niewydolność nerek/niewydolność wielonarządową z sepsą (3) oraz przewlekłą obturacyjna chorobę płuc (7) mają najkrótszy czas - zatem ci pacjenci mieli krótszy czas życia od pozostałych chorób. Zatem te dwie choroby wyróżniają się szybkim postępem rozwoju. Grupy chorób: marskość wątroby (2), śpiączka (4), rak okrężnicy (6) oraz niewydolność wielonarządowa z nowotworem złośliwym (8) charakteryzują się ponadto dużą zmiennością wyników. Widzimy także tutaj dużo obserwacji zakwalifikowanych jako odstające, ale rozważania o nich były przeprowadzone w sekcji **Wartości odstające**.

-   `dzclass` vs `slos`

```{r}
ggplot(dane3, aes(x=dzclass, y=slos, fill=dzclass)) + 
        geom_boxplot()
```

Wykres pudełkowy dla klas chorób przedstawia, że pacjenci chorzy na przewlekłą obturacyjną chorobę płuc/zastoinową niewydolność serca/marskość wątroby (2) mają szeroki zakres długości pobytu w szpitalu. Z kolei pacjenci chorzy na ostrą niewydolność nerek/niewydolność wielonarządową (1) mają najniższą medianę dni pobytu w szpitalu oraz najmniejszą zmienność spośród pozostałych klas chorób.

-   `dzclass` vs `d.time`

```{r}
ggplot(dane3, aes(x=dzclass, y=d.time, fill=dzclass)) + 
        geom_boxplot()
```

Porównując klasy chorób, pacjenci z rakiem (3) mają znacznie niższą medianę czasu do zgonu - zatem rak jest tutaj szybko postępującą chorobą przyczyniającą się do szybkiego zgonu pacjenta. Najwyższą medianą dni do momentu zgonu wyróżniają się pacjenci będący w śpiączce.

# Budowa modeli

W tej części pracy zostaną wdrożone modele sieci gęstych opartych o różne architektury.

Jeszcze przed budową modeli, zbiór danych zostanie odpowiednio przygotowany - znormalizowane zostaną wszystkie numeryczne predyktory, a wszystkie kategoryczne zostaną przekształcone na typ *dummy* wykorzystując *one-hot-encoding*. Zbiór danych uczących będzie stanowił 70% pierwotnego zbioru, a testowych 30%.

```{r}
set.seed(2024)
split <- initial_split(dane3, prop = 0.7)
df_train <- training(split)
df_test <- testing(split)

rec <- recipe(death+hospdead+sfdm2 ~ ., data = df_train) |> 
  step_normalize(all_numeric_predictors()) |> 
  step_dummy(all_factor_predictors(), one_hot = TRUE)

df_train_trans <- rec |> 
  prep() |> 
  bake(new_data = NULL)

df_test_trans <- rec |> 
  prep() |> 
  bake(new_data = df_test)

train_features <- df_train_trans[,-c(26:28)]
train_features |> dim()
train_targets <- df_train_trans[,c(26:28)]
train_targets |> dim()

test_features <- df_test_trans[,-c(26:28)]
test_features |> dim()
test_targets <- df_test_trans[,c(26:28)]
test_targets |> dim()

train_targets$sfdm2 <- to_categorical(train_targets$sfdm2, num_classes = 5)

train_targets <- as.matrix(train_targets)
train_targets <- as.numeric(train_targets) |> matrix(nrow = 6373, ncol = 7, byrow = F) |> as.matrix()
colnames(train_targets) <- list("death", "hospdead", "sfdm2.1", "sfdm2.2", "sfdm2.3", "sfdm2.4", "sfdm2.5")
```

### Model 1

```{r}
input <- layer_input(shape = c(51))
hidden <- layer_dense(input, units = 8, activation = 'relu')

#dwa wyjścia binarne (death, hospdead)
binary_output1 <- layer_dense(hidden, units = 1, activation = 'sigmoid', name = 'binary_output1')
binary_output2 <- layer_dense(hidden, units = 1, activation = 'sigmoid', name = 'binary_output2')
#jedno wyjście wieloklasowe (5 klas) (sfdm2)
multi_class_output <- layer_dense(hidden, units = 5, activation = 'softmax', name = 'multi_class_output')

model <- keras_model(inputs = input, outputs = list(binary_output1, binary_output2, multi_class_output))

model |> compile(
  optimizer = 'adam',
  loss = list(
    binary_output1 = 'binary_crossentropy',
    binary_output2 = 'binary_crossentropy',
    multi_class_output = 'categorical_crossentropy'
  ),
  metrics = 'accuracy'
)
```

```{r echo=FALSE}
#history <- model |> fit(
#  as.matrix(train_features), 
#  list(
#    binary_output1 = train_targets[, "death"],
#    binary_output2 = train_targets[, "hospdead"],
#    multi_class_output = train_targets[, grep("^sfdm2", colnames(train_targets))]
#  ),
#  epochs = 40,
#  batch_size = 32,
#  validation_split = 0.2
#)

#saveRDS(history, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history1_v2.rds")
#save_model_tf(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model1_v2.keras")
```

```{r}
history1 <- readRDS("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history1_v2.rds")
model1 <- load_model_hdf5("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model1_v2.keras")

plot(history1)
```

Na podstawie powyższego rysunku, widzimy, że dla tego (prostego) modelu nie występuje przeuczenie. Zarówno na zbiorze uczącym, jak i testowym, model ma podobne wyniki.

```{r}
test_targets <- as.matrix(test_targets)
test_targets <- as.numeric(test_targets) |> matrix(nrow = 2732, ncol = 7, byrow = F) |> as.matrix()
colnames(test_targets) <- list("death", "hospdead", "sfdm2.1", "sfdm2.2", "sfdm2.3", "sfdm2.4", "sfdm2.5")

model1 |> 
  evaluate(as.matrix(test_features), list(test_targets[, "death"],test_targets[, "hospdead"],test_targets[, grep("^sfdm2", colnames(test_targets))])) |> kable(caption = "Metryki modelu na zbiorze testowym", col.names = "Wartość", digits = 4) |> kable_styling(full_width = F) |> column_spec(1, background = "#F9F1F0")
```

Po ewaluacji modelu na danych testowych, miara *accuracy* dla binarnej klasyfikacji zmiennej `death` wynosi 50%. Dla drugiej zmiennej binarnej `hospdead` wynosi ona 37%, a dla zadania klasyfikacji wielostanowej zmiennej `sfdm2` wynosi ona 37%.

```{r}
x <- model1 |> predict(as.matrix(test_features))

cm <- data.frame(x[[1]] |> k_argmax() |> as.vector(), df_test$death)
colnames(cm) <- c("pred", "truth")
cm$pred <- factor(cm$pred, levels = c(0:1))
cm |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Przedstawiona powyżej macierz klasyfikacji dla zmiennej `death` wskazuje, że model w większości przypadków się pomylił i pacjenta martwego zaklasyfikował jako żyjącego.

```{r}
cm2 <- data.frame(x[[2]] |> k_argmax() |> as.vector(), df_test$hospdead)
colnames(cm2) <- c("pred", "truth")
cm2$pred <- factor(cm2$pred, levels = c(0:1))
cm2 |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Dla zmiennej `hospdead` model ten 748 razy zaklasyfikował pacjenta, który umarł w szpitalu jako tego, który w nim nie umarł.

```{r}
cm3 <- data.frame(x[[3]] |> k_argmax() |> as.vector(), df_test$sfdm2)
colnames(cm3) <- c("pred", "truth")
cm3$pred <- factor(cm3$pred, levels = c(0:4))
cm3 |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Dla klasyfikacji wielostanowej, wyniki nie są satysfakcjonujące. Najtruniej było mu sklasyfikować pacjentów do klasy 2 (pacjent nie był w stanie wykonywać 4 lub więcej czynności życia codziennego w 2. miesiącu po rozpoczęciu badania). Jednak pomyłki występują w każdym z pięciu możliwych stanów pacjenta.

### Model 2

```{r}
outputs <- input |> 
  layer_flatten() |> 
  layer_dense(units = 64, activation = 'relu') |> 
  layer_dense(units = 32, activation = 'relu')

model <- keras_model(inputs = input, outputs = list(binary_output1, binary_output2, multi_class_output))

model |> compile(
  optimizer = 'adam',
  loss = list(
    binary_output1 = 'binary_crossentropy',
    binary_output2 = 'binary_crossentropy',
    multi_class_output = 'categorical_crossentropy'
  ),
  metrics = 'accuracy'
)
```

```{r echo=FALSE}
#history <- model |> fit(
#  as.matrix(train_features), 
#  list(
#    binary_output1 = train_targets[, "death"],
#    binary_output2 = train_targets[, "hospdead"],
#    multi_class_output = train_targets[, grep("^sfdm2", colnames(train_targets))]
#  ),
#  epochs = 40,
#  batch_size = 32,
#  validation_split = 0.2
#)

#saveRDS(history, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history2_v2.rds")
#save_model_tf(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model2_v2.keras")
```

```{r}
history2 <- readRDS("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history2_v2.rds")
model2 <- load_model_hdf5("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model2_v2.keras")

plot(history2)
```

Tym razem model składa się z z jednej warstwy *flatten* oraz dwóch warstw gęstych z 64 oraz 32 neuronami w każdej z nich. Historia uczenia się tego modelu, która przebiegała na 40 epokach, wygląda bardzo podobnie do poprzedniego modelu. Dostrze można, że zarówno na zbiorze uczącym, jak i walidacyjnym, metryka *accuracy* osiąga satysfakcjonujące wartości - dla klasyfikacji binarnych jest to około 90%, a dla klasyfikacji wielostanowej jest to około 70%.

```{r}
model2 |> 
  evaluate(as.matrix(test_features), list(test_targets[, "death"],test_targets[, "hospdead"],test_targets[, grep("^sfdm2", colnames(test_targets))])) |> kable(caption = "Metryki modelu na zbiorze testowym", col.names = "Wartość", digits = 4) |> kable_styling(full_width = F) |> column_spec(1, background = "#F9F1F0")
```

Jednak po ewaluacji tego modelu na danych testowych, osiągnięto znacznie gorsze wyniki. Model nie jest rozbudowany, a mimo to wyniki dla wyjścia wieloklasowego znacząco spadły - *accuracy* wynosi tu jedynie 3%. Dla wyjść binarnych otrzymano za to nieco lepsze wyniki - *accuracy* wynosi dla nich około 60%.

```{r}
x <- model2 |> predict(as.matrix(test_features))

cm <- data.frame(x[[1]] |> k_argmax() |> as.vector(), df_test$death)
colnames(cm) <- c("pred", "truth")
cm$pred <- factor(cm$pred, levels = c(0:1))
cm |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Macierz klasyfikacji zmiennej `death` wygląda bardzo podobnie jak dla modelu wyżej. Aż 1883 razy model błędnie sklasyfikował pacjenta, że będzie żył.

```{r}
cm2 <- data.frame(x[[2]] |> k_argmax() |> as.vector(), df_test$hospdead)
colnames(cm2) <- c("pred", "truth")
cm2$pred <- factor(cm2$pred, levels = c(0:1))
cm2 |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Dla drugiej binarnej zmiennej `hospdead` - śmierć w szpitalu - błędnie zostało sklasyfikowanych 748 pacjentów.

```{r}
cm3 <- data.frame(x[[3]] |> k_argmax() |> as.vector(), df_test$sfdm2)
colnames(cm3) <- c("pred", "truth")
cm3$pred <- factor(cm3$pred, levels = c(0:4))
cm3 |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Dla zmiennej wieloklasowej natomiast, najwięcej błednych klasyfikacji odnotowano dla poziomu 2 (pacjent nie był w stanie wykonywać 4 lub więcej czynności życia codziennego w 2. miesiącu po rozpoczęciu badania).

### Model 3

Kolejny model będzie bardziej rozbudowany. Po warstwie wejściowej następuje warstwa *flatten*, po której są cztery pary naprzemiennych warstw sieci gęstej oraz warstwy *dropout*.

```{r}
outputs <- input |>
  layer_flatten() |> 
  layer_dense(units = 32, activation = 'relu') |> 
  layer_dropout(0.2) |> 
  layer_dense(units = 64, activation = 'relu') |> 
  layer_dropout(0.1) |> 
  layer_dense(units = 64, activation = 'relu') |>
  layer_dropout(0.2) |> 
  layer_dense(units = 32, activation = 'relu') |> 
  layer_dropout(0.1)

model <- keras_model(inputs = input, outputs = list(binary_output1, binary_output2, multi_class_output))

model |> compile(
  optimizer = 'adam',
  loss = list(
    binary_output1 = 'binary_crossentropy',
    binary_output2 = 'binary_crossentropy',
    multi_class_output = 'categorical_crossentropy'
  ),
  metrics = 'accuracy'
)
```

```{r echo=FALSE}
#history <- model |> fit(
#  as.matrix(train_features), 
#  list(
#    binary_output1 = train_targets[, "death"],
#    binary_output2 = train_targets[, "hospdead"],
#    multi_class_output = train_targets[, grep("^sfdm2", colnames(train_targets))]
#  ),
#  epochs = 40,
#  batch_size = 32,
#  validation_split = 0.2
#)

#saveRDS(history, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history3_v2.rds")
#save_model_tf(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model3_v2.keras")
```

```{r}
history3 <- readRDS("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history3_v2.rds")
model3 <- load_model_hdf5("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model3_v2.keras")

plot(history3)
```

Dla tego modelu zaobserwować można lekkie przeuczenie - wyniki na zbiorze uczącym są nieco wyższe niż na zbiorze walidacyjnym dla każdego z wyjść modelu.

```{r}
model3 |> 
  evaluate(as.matrix(test_features), list(test_targets[, "death"],test_targets[, "hospdead"],test_targets[, grep("^sfdm2", colnames(test_targets))])) |> kable(caption = "Metryki modelu na zbiorze testowym", col.names = "Wartość", digits = 4) |> kable_styling(full_width = F) |> column_spec(1, background = "#F9F1F0")
```

Po ewaluacji modelu na danych testowych, *accuracy* każdego z wyjścia tego modelu, nie zmieniła się względem modelu poprzedniego. Zatem rozbudowanie modelu nie poprawiło jego wyników.

```{r}
x <- model3 |> predict(as.matrix(test_features))

cm <- data.frame(x[[2]] |> k_argmax() |> as.vector(), df_test$hospdead)
colnames(cm) <- c("pred", "truth")
cm$pred <- factor(cm$pred, levels = c(0:1))
cm |> conf_mat(truth = truth, estimate = pred) |> 
autoplot(type = "heatmap")
```

Wyniki klasyfikacji dla zmiennej `hospdead` są identyczne jak dla modelu 1.

### Model 4

Ten model będzie składał się z 3 warstw gęstych oddzielonymi warstwami *dropout*. Dodatkowo, podczas uczenia zostaną zastosowane *callbacks*, które powodują wcześniejsze zakończenie tego procesu, jeśli wyniki modelu się nie poprawiają.

```{r}
outputs <- input |> 
  layer_dense(units = 64, activation = 'relu') |> 
  layer_dropout(0.2) |> 
  layer_dense(units = 128, activation = 'relu') |> 
  layer_dropout(0.2) |> 
  layer_dense(units = 64, activation = 'relu')

model <- keras_model(inputs = input, outputs = list(binary_output1, binary_output2, multi_class_output))

model |> compile(
  optimizer = 'adam',
  loss = list(
    binary_output1 = 'binary_crossentropy',
    binary_output2 = 'binary_crossentropy',
    multi_class_output = 'categorical_crossentropy'
  ),
  metrics = 'accuracy'
)
```

```{r echo=FALSE}
#history <- model |> fit(
#  as.matrix(train_features), 
#  list(
#    binary_output1 = train_targets[, "death"],
#    binary_output2 = train_targets[, "hospdead"],
#    multi_class_output = train_targets[, grep("^sfdm2", colnames(train_targets))]
#  ),
#  epochs = 30,
#  batch_size = 32,
#  validation_split = 0.2,
#  callbacks = list(callback_early_stopping(monitor = "val_binary_output2_accuracy", patience = 5, restore_best_weights = TRUE))
#)

#saveRDS(history, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history4_v2.rds")
#save_model_hdf5(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model4_v2.h5")
#save_model_tf(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model4_v2.keras")
```

```{r}
history4 <- readRDS("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history4_v2.rds")
model4 <- load_model_hdf5("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model4_v2.keras")

plot(history4)
```

W tym przypadku uczenie modelu zostało zatrzymane już po szóstej epoce. Ponownie jak poprzednio, zauważyć można przeuczenie modelu, jednak nie jest ono tak znaczące.

```{r}
model4 |> 
  evaluate(as.matrix(test_features), list(test_targets[, "death"],test_targets[, "hospdead"],test_targets[, grep("^sfdm2", colnames(test_targets))])) |> kable(caption = "Metryki modelu na zbiorze testowym", col.names = "Wartość", digits = 4) |> kable_styling(full_width = F) |> column_spec(1, background = "#F9F1F0")
```

Dla tego modelu, wyniki ewaluacji na danych testowych są identyczne jak dla poprzednich modeli.

### Model 5

```{r}
outputs <- input |> 
  layer_dense(units = 4, activation = 'relu') |> 
  layer_dense(units = 8, activation = 'relu')

model <- keras_model(inputs = input, outputs = list(binary_output1, binary_output2, multi_class_output))

model |> compile(
  optimizer = 'adam',
  loss = list(
    binary_output1 = 'binary_crossentropy',
    binary_output2 = 'binary_crossentropy',
    multi_class_output = 'categorical_crossentropy'
  ),
  metrics = 'accuracy'
)
```

```{r echo=FALSE}
#history <- model |> fit(
#  as.matrix(train_features), 
#  list(
#    binary_output1 = train_targets[, "death"],
#    binary_output2 = train_targets[, "hospdead"],
#    multi_class_output = train_targets[, grep("^sfdm2", colnames(train_targets))]
#  ),
#  epochs = 30,
#  batch_size = 32,
#  validation_split = 0.2,
#  callbacks = list(callback_early_stopping(monitor = "val_binary_output2_accuracy", patience = 5, restore_best_weights = TRUE))
#)

#saveRDS(history, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history5_v2.rds")
#save_model_hdf5(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model5_v2.h5")
#save_model_tf(model, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model5_v2.keras")
```

```{r}
history5 <- readRDS("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\history5_v2.rds")
model5 <- load_model_hdf5("C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\model5_v2.keras")

plot(history5)
```

```{r}
model5 |>  
  evaluate(as.matrix(test_features), list(test_targets[, "death"],test_targets[, "hospdead"],test_targets[, grep("^sfdm2", colnames(test_targets))])) |> kable(caption = "Metryki modelu na zbiorze testowym", col.names = "Wartość", digits = 4) |> kable_styling(full_width = F) |> column_spec(1, background = "#F9F1F0")
```

Po ponownym zbudowaniu prostszego modelu, otrzymano metryki bardzo zbliżone do modeli bardziej rozbudowanych.

# Podsumowanie

W pracy przedstawiono wszystkie etapy zmierzające do budowy najlepszego modelu zaawansowanego uczenia maszynowego do zadania typu *multioutput* (wiele wyjść) oraz zbudowano takie modele z różnymi architekturami. Modele bardziej rozbudowane okazywały się być niebardziej skuteczne niż te mniej rozbudowane. Trudnym zadaniem okazało się zbudowanie takiego modelu, który skutecznie będzie przewidywał zmienną wieloklasową (`sfdm2`) przy przewidywaniu także zmiennych `death` oraz `hospdead`. Modele z prostszymi architekturami skutkowały metryką *accuracy* dla wszystkich wyjść na poziomie 40-50%. Te z bardziej złożonymi architekturami, okazywały się być bardziej skuteczne dla wyjść binarnych, a znacznie mniej skuteczne dla wyjścia wieloklasowego.

Być może inne modele uczenia maszynowego okazałyby się lepszym rozwiązaniem do tego zadania, jak chociażby model SVM. Może właśnie prostsze modele skutkowałyby większą skutecznością. Warto rozwinąć tę pracę pod tym kątem.

```{r echo=FALSE}
#saveRDS(train_features, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\train_features.rds")
#saveRDS(train_targets, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\train_targets.rds")
#saveRDS(test_features, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\test_features.rds")
#saveRDS(test_targets, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\test_targets.rds")
#saveRDS(df_test, "C:\\Users\\wnadw\\Desktop\\Pliki studia\\Rok 4\\II stopień\\semestr 1\\Zaawansowane metody uczenia maszynowego\\projekt\\dane UCI\\multiclass\\support2\\multiclass\\df_test.rds")
```
